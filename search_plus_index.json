{"./":{"url":"./","title":"index","keywords":"","body":"spdk文档主页 Copyright shellspicker all right reserved，powered by shellspicker修改时间: 2020-09-02 10:16:23 "},"content/thread_channel_device.html":{"url":"content/thread_channel_device.html","title":"spdk设备模型","keywords":"","body":"spdk设备模型 包含3个组件: thread, io_channel, io_device. 一句话解释就是: thread通过io_channel去操作io_device. 此篇文章的主角不是thread, 而是io_channel和io_device. 其中thread在spdk线程模型里面也会见到, 可以认为thread和线程模型关系大一点, 这里暂时不管线程模型也可以. io_device, 即设备的抽象. io_channel, 即设备行为的抽象. 先来看这3个组件的联系, 上图: 这个图恰好是3层, 以thread--io_channel--io_device的层次表示. 细心一看, 1个thread到1个io_device的路线, 有且仅有1个io_channel. 所以这里一共2个thread, 2个io_device, 从上到下一共有4条路线. 考虑一下这种结构的意义, 可以使得不同的线程访问相同的设备, 行为上是独立的, 以便达到并行的效果. 来看一下3个组件的细节. thread struct spdk_thread struct spdk_thread { TAILQ_HEAD(, spdk_io_channel) io_channels; }; thread到io_channel为1对多的关系. io_channel struct spdk_io_channel struct spdk_io_channel { struct spdk_thread *thread; struct io_device *dev; uint32_t ref; }; io_channel到thread为1对1的关系. io_channel到io_device为1对1的关系. 前面提到了, io_channel是抽象的行为, 但是此结构体内并没有void *, 可以直接到源码里看, 这个结构体后面有一段注释, 这个结构体创建出来会分配一个额外的空间, 引用到具体的硬件相关或者子设备的spdk_io_channel上. Modules will allocate extra memory off the end of this structure to store references to hardware-specific references (i.e. NVMe queue pairs, or references to child device spdk_io_channels (i.e. virtual bdevs). 记住这个额外的空间, 后面会多次提到. io_device struct io_device struct io_device { void *io_device; spdk_io_channel_create_cb create_cb; uint32_t ctx_size; }; 由于io_device是个抽象的概念, 所以, 真实的设备其实是struct io_device里面的void *io_device. 注意这里的ctx_size, 即spdk_io_channel里面的额外空间大小. 而create_cb, 则是和这个额外空间相关的一个函数. 现在可以暂时理解为, io_device会使用spdk_io_channel的额外空间来做一些额外的事情. helper function spdk_io_device_register 注册一个设备. void spdk_io_device_register( void *io_device, spdk_io_channel_create_cb create_cb, spdk_io_channel_destroy_cb destroy_cb, uint32_t ctx_size, const char *name) { struct io_device *dev; dev = calloc(1, sizeof(struct io_device)); dev->io_device = io_device; dev->create_cb = create_cb; dev->ctx_size = ctx_size; /* ...... 最后会把dev放到一个全局设备链表里. */ } 参数1, 真实的io_device. 参数2, spdk_io_channel对应的额外空间的使用方法. 参数4, spdk_io_channel中的额外空间大小. 主要是初始化一些成员. spdk_io_channel_create_cb spdk_io_channel对应的额外空间的使用方法. typedef int(* spdk_io_channel_create_cb) (void *io_device, void *ctx_buf); 参数1, 真实的io_device. 参数2, spdk_io_channel中的额外空间的地址. 注意这里ctx_buf, 表示一个地址, 就是说此时已经把额外空间分配出来了, 这里相当于是把额外空间和具体的device关联起来. 至于什么时候创建的额外空间, 先不用关心. 这是一个函数指针, 这里以函数称呼之. 这个函数具体做了什么事情, 值得看一下, 因为这里算是首次使用这个额外空间. 不过此篇文章并不会讲实例, 所以想知道这个函数做了什么事情, 在具体分析实例的文章里会讲到. spdk_get_io_channel 创建/获取spdk_io_channel的方法. struct spdk_io_channel *(void *io_device) { struct spdk_io_channel *ch; struct spdk_thread *thread; struct io_device *dev; /* ...... 在此之前肯定已经对void *io_device注册过了, 这里找到了其对应的struct io_device, 存为dev. thread直接从当前线程获取. */ TAILQ_FOREACH(ch, &thread->io_channels, tailq) { if (ch->dev == dev) { ch->ref++; return ch; } } ch = calloc(1, sizeof(*ch) + dev->ctx_size); ch->dev = dev; ch->thread = thread; dev->create_cb(io_device, (uint8_t *)ch + sizeof(*ch)); return ch; } 注意开头3个结构体, 此函数把3个组件都关联在一起了, 可以说是核心函数了. thread->io_channels的遍历, 我们可以看出来这个函数能推导出文章最初的层次图的含义: 1个thread对应1个io_device, 用的只有1个io_channel. 同一个thread多次访问io_device, 只会让同一个io_channel的引用计数增加而已. struct spdk_io_channel分配出来即包含了额外空间的大小, 之后马上调用了create_cb 这个过程, 有点类似设计模式里面的单例模式, 获取实例和初始化实例的过程都包含了. spdk_io_channel_get_ctx 获得spdk_io_channel之后额外空间的地址. void *spdk_io_channel_get_ctx(struct spdk_io_channel *ch) { return (uint8_t *)ch + sizeof(*ch); } 总结 主角2位: io_device和io_channel. io_device对应结构体struct io_device. io_channel对应结构体struct spdk_io_channel. 主要流程: 注册设备, 指定额外空间大小和想用额外空间来做事的函数. 首次得到spdk_io_channel的时候, 创建额外空间, 且执行额外空间对应的处理函数(类似单例模式的初始化). 如果忘了额外空间的意义, 回到io_channel. spdk_io_channel的额外空间可以指向另外的spdk_io_channel, 有点递归的意思, 当一个spdk_io_channel的额外空间指向了具体的硬件, 那么说明不会再有下一层spdk_io_channel了. 因为这里没有实例分析, 所以自行想象一下这个spdk_io_channel层层嵌套的情景. 疑问 为何同样是抽象, struct io_device是用void *实现, struct spdk_io_channel是用额外空间实现? struct spdk_io_channel能否把额外空间声明成一个void *? Copyright shellspicker all right reserved，powered by shellspicker修改时间: 2020-09-07 10:21:24 "},"content/detail.html":{"url":"content/detail.html","title":"详细分析","keywords":"","body":"实例分析 从还是从spdk_io_device_register开始, 分析其io_device对应的io_channel做的额外操作. 标题2: 文件. 标题3: 函数. 正文: 此函数内必定有个spdk_io_device_register调用, 然后展开分析. 有些结构体, 这里不会列出其内容, 自行查看代码. lib/bdev/bdev.c spdk_bdev_initialize spdk_io_device_register(&g_bdev_mgr, bdev_mgmt_channel_create, bdev_mgmt_channel_destroy, sizeof(struct spdk_bdev_mgmt_channel), \"bdev_mgr\"); io_device为g_bdev_mgr, 类型为struct spdk_bdev_mgr. struct spdk_bdev_mgr { spdk_mempool *bdev_io_pool; }; 主要是管理一些mempool的分配. 额外空间为struct spdk_bdev_mgmt_channel. struct spdk_bdev_mgmt_channel { bdev_io_stailq_t per_thread_cache; TAILQ_HEAD(, spdk_bdev_shared_resource) shared_resources; TAILQ_HEAD(, spdk_bdev_io_wait_entry) io_wait_queue; }; 函数bdev_mgmt_channel_create. int bdev_mgmt_channel_create(void *io_device, void *ctx_buf) { struct spdk_bdev_mgmt_channel *ch = ctx_buf; struct spdk_bdev_io *bdev_io; STAILQ_INIT(&ch->per_thread_cache); for (i = 0; i bdev_io_cache_size; i++) { bdev_io = spdk_mempool_get(g_bdev_mgr.bdev_io_pool); STAILQ_INSERT_HEAD(&ch->per_thread_cache, bdev_io, internal.buf_link); } TAILQ_INIT(&ch->shared_resources); TAILQ_INIT(&ch->io_wait_queue); } 把g_bdev_mgr的bdev_io_pool按照配置分配到spdk_bdev_mgmt_channel的per_thread_cache里. bdev_init spdk_io_device_register(__bdev_to_io_dev(bdev), bdev_channel_create, bdev_channel_destroy, sizeof(struct spdk_bdev_channel), bdev_name); io_device为__bdev_to_io_dev(bdev). 可以单纯把其看作是bdev, __bdev_to_io_dev可以暂时无视. 类型为spdk_bdev. struct spdk_bdev { void *ctxt; }; 额外空间为struct spdk_bdev_channel. struct spdk_bdev_channel { struct spdk_bdev *bdev; struct spdk_io_channel *channel; }; 其中的channel是子channel. 函数bdev_channel_create. int bdev_channel_create(void *io_device, void *ctx_buf) { struct spdk_bdev *bdev = __bdev_from_io_dev(io_device); struct spdk_bdev_channel *ch = ctx_buf; struct spdk_io_channel› *mgmt_io_ch; struct spdk_bdev_mgmt_channel› *mgmt_ch; ch->bdev = bdev; ch->channel = bdev->fn_table->get_io_channel(bdev->ctxt); mgmt_io_ch = spdk_get_io_channel(&g_bdev_mgr); mgmt_ch = spdk_io_channel_get_ctx(mgmt_io_ch); } 绑定了spdk_bdev_channel->bdev为spdk_io_device_register相关的bdev.获取了子channel.获取了g_bdev_mgr->get_io_channel, 得到struct spdk_bdev_mgmt_channel. module/bdev/nvme/bdev_nvme.c bdev_nvme_library_init spdk_io_device_register(&g_nvme_bdev_ctrlrs, bdev_nvme_poll_group_create_cb, bdev_nvme_poll_group_destroy_cb, sizeof(struct nvme_bdev_poll_group), \"bdev_nvme_poll_groups\"); io_device为g_nvme_bdev_ctrlrs, 类型为struct nvme_bdev_ctrlrs(其实是一个struct nvme_bdev_ctrlr的链表). struct nvme_bdev_ctrlrs { }; 这里不关心其结构, 因为之后用不到. 额外空间为struct nvme_bdev_poll_group struct nvme_bdev_poll_group { struct spdk_nvme_poll_group *group; struct spdk_poller *poller; }; 函数bdev_nvme_poll_group_create_cb. int bdev_nvme_poll_group_create_cb(void *io_device, void *ctx_buf) { struct nvme_bdev_poll_group *group = ctx_buf; group->group = spdk_nvme_poll_group_create(group); group->poller = spdk_poller_register(bdev_nvme_poll, group, g_opts.nvme_ioq_poll_period_us); } 创建了group(类型为struct spdk_nvme_poll_group)创建了poller, 函数为bdev_nvme_poll. create_ctrlr spdk_io_device_register(nvme_bdev_ctrlr, bdev_nvme_create_cb, bdev_nvme_destroy_cb, sizeof(struct nvme_io_channel), name); io_device为nvme_bdev_ctrlr, 类型为struct nvme_bdev_ctrlr. struct nvme_bdev_ctrlr { struct spdk_nvme_ctrlr› *ctrlr; struct spdk_nvme_transport_id› trid; }; 可以看到这里的结构体比较接近硬件信息了. 额外空间为struct nvme_io_channel. struct nvme_io_channel { struct spdk_nvme_qpair› *qpair; struct nvme_bdev_poll_group›*group; }; 函数bdev_nvme_create_cb. int bdev_nvme_create_cb(void *io_device, void *ctx_buf) { struct nvme_bdev_ctrlr *nvme_bdev_ctrlr = io_device; struct nvme_io_channel *ch = ctx_buf; struct spdk_io_channel *pg_ch = NULL; ch->qpair = spdk_nvme_ctrlr_alloc_io_qpair(nvme_bdev_ctrlr->ctrlr, &opts, sizeof(opts)); pg_ch = spdk_get_io_channel(&g_nvme_bdev_ctrlrs); ch->group = spdk_io_channel_get_ctx(pg_ch); spdk_nvme_poll_group_add(ch->group->group, ch->qpair); spdk_nvme_ctrlr_connect_io_qpair(nvme_bdev_ctrlr->ctrlr, ch->qpair); } 分配了io_qpair.获取了g_nvme_bdev_ctrlrs->get_io_channel, 得到了struct nvme_bdev_poll_group. module/bdev/zone_block/vbdev_zone_block.c zone_block_register spdk_io_device_register(bdev_node, _zone_block_ch_create_cb, _zone_block_ch_destroy_cb, sizeof(struct zone_block_io_channel), name->vbdev_name); io_device为bdev_node, 类型为struct bdev_zone_block. struct bdev_zone_block { struct spdk_bdev bdev; struct spdk_bdev_desc *base_desc; }; base_desc即为zone模块所依赖的nvme模块对应的bdev的描述符. 额外空间为struct zone_block_io_channel. struct zone_block_io_channel { struct spdk_io_channel *base_ch; }; 类似的, base_ch也是zone模块所依赖的nvme模块对应的设备的io_channel. 即子channel. 函数_zone_block_ch_create_cb. int _zone_block_ch_create_cb(void *io_device, void *ctx_buf) { struct zone_block_io_channel *bdev_ch = ctx_buf; struct bdev_zone_block *bdev_node = io_device; bdev_ch->base_ch = spdk_bdev_get_io_channel(bdev_node->base_desc); } 获取了子channel. Copyright shellspicker all right reserved，powered by shellspicker修改时间: 2020-09-07 11:27:52 "}}